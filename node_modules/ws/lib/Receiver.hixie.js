function Receiver() {
 if (this instanceof Receiver == !1) throw new TypeError("Classes can't be function-called");
 this.state = EMPTY, this.buffers = [], this.messageEnd = -1, this.spanLength = 0, this.dead = !1, this.onerror = function() {}, this.ontext = function() {}, this.onbinary = function() {}, this.onclose = function() {}, this.onping = function() {}, this.onpong = function() {}
}

function bufferIndex(e, t) {
 for (var s = 0, n = e.length; n > s; ++s)
  if (e[s] === t) return s;
 return -1
}
var util = require("util"),
 EMPTY = 0,
 BODY = 1,
 BINARYLENGTH = 2,
 BINARYBODY = 3;
module.exports = Receiver, Receiver.prototype.add = function(e) {
 function t() {
  if (s.state === EMPTY) {
   if (2 == e.length && 255 == e[0] && 0 == e[1]) return s.reset(), void s.onclose();
   if (128 === e[0]) s.messageEnd = 0, s.state = BINARYLENGTH, e = e.slice(1);
   else {
    if (0 !== e[0]) return void s.error("payload must start with 0x00 byte", !0);
    e = e.slice(1), s.state = BODY
   }
  }
  if (s.state === BINARYLENGTH) {
   for (var t = 0; t < e.length && 128 & e[t];) s.messageEnd = 128 * s.messageEnd + (127 & e[t]), ++t;
   t < e.length && (s.messageEnd = 128 * s.messageEnd + (127 & e[t]), s.state = BINARYBODY, ++t), t > 0 && (e = e.slice(t))
  }
  if (s.state === BINARYBODY) {
   var n = s.messageEnd - s.spanLength;
   return e.length >= n ? (s.buffers.push(e), s.spanLength += n, s.messageEnd = n, s.parse()) : (s.buffers.push(e), void(s.spanLength += e.length))
  }
  return s.buffers.push(e), -1 != (s.messageEnd = bufferIndex(e, 255)) ? (s.spanLength += s.messageEnd, s.parse()) : void(s.spanLength += e.length)
 }
 for (var s = this; e;) e = t()
}, Receiver.prototype.cleanup = function() {
 this.dead = !0, this.state = EMPTY, this.buffers = []
}, Receiver.prototype.parse = function() {
 for (var e = new Buffer(this.spanLength), t = 0, s = 0, n = this.buffers.length; n - 1 > s; ++s) {
  var i = this.buffers[s];
  i.copy(e, t), t += i.length
 }
 var r = this.buffers[this.buffers.length - 1];
 this.messageEnd > 0 && r.copy(e, t, 0, this.messageEnd), this.state !== BODY && --this.messageEnd;
 var h = null;
 return this.messageEnd < r.length - 1 && (h = r.slice(this.messageEnd + 1)), this.reset(), this.ontext(e.toString("utf8")), h
}, Receiver.prototype.error = function(e, t) {
 return this.reset(), this.onerror(e, t), this
}, Receiver.prototype.reset = function(e) {
 this.dead || (this.state = EMPTY, this.buffers = [], this.messageEnd = -1, this.spanLength = 0)
};
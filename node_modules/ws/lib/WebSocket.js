function WebSocket(e, t, o) {
 return this instanceof WebSocket == !1 ? new WebSocket(e, t, o) : (EventEmitter.call(this), t && !Array.isArray(t) && "object" == typeof t && (o = t, t = null), "string" == typeof t && (t = [t]), Array.isArray(t) || (t = []), this._socket = null, this._ultron = null, this._closeReceived = !1, this.bytesReceived = 0, this.readyState = null, this.supports = {}, this.extensions = {}, void(Array.isArray(e) ? initAsServerClient.apply(this, e.concat(o)) : initAsClient.apply(this, [e, t, o])))
}

function MessageEvent(e, t, o) {
 this.type = "message", this.data = e, this.target = o, this.binary = t
}

function CloseEvent(e, t, o) {
 this.type = "close", this.wasClean = "undefined" == typeof e || 1e3 === e, this.code = e, this.reason = t, this.target = o
}

function OpenEvent(e) {
 this.type = "open", this.target = e
}

function buildHostHeader(e, t, o) {
 var r = t;
 return t && (e && 443 != o || !e && 80 != o) && (r = r + ":" + o), r
}

function initAsServerClient(e, t, o, r) {
 r = new Options({
  protocolVersion: protocolVersion,
  protocol: null,
  extensions: {}
 }).merge(r), this.protocol = r.value.protocol, this.protocolVersion = r.value.protocolVersion, this.extensions = r.value.extensions, this.supports.binary = "hixie-76" !== this.protocolVersion, this.upgradeReq = e, this.readyState = WebSocket.CONNECTING, this._isServer = !0, "hixie-76" === r.value.protocolVersion ? establishConnection.call(this, ReceiverHixie, SenderHixie, t, o) : establishConnection.call(this, Receiver, Sender, t, o)
}

function initAsClient(e, t, o) {
 if (o = new Options({
   origin: null,
   protocolVersion: protocolVersion,
   host: null,
   headers: null,
   protocol: t.join(","),
   agent: null,
   pfx: null,
   key: null,
   passphrase: null,
   cert: null,
   ca: null,
   ciphers: null,
   rejectUnauthorized: null,
   perMessageDeflate: !0,
   localAddress: null
  }).merge(o), 8 !== o.value.protocolVersion && 13 !== o.value.protocolVersion) throw new Error("unsupported protocol version");
 var r = url.parse(e),
  n = "ws+unix:" === r.protocol;
 if (!r.host && !n) throw new Error("invalid url");
 var s, i = "wss:" === r.protocol || "https:" === r.protocol,
  a = i ? https : http,
  c = r.port || (i ? 443 : 80),
  l = r.auth,
  u = {};
 o.value.perMessageDeflate && (s = new PerMessageDeflate(typeof o.value.perMessageDeflate !== !0 ? o.value.perMessageDeflate : {}, !1), u[PerMessageDeflate.extensionName] = s.offer()), this._isServer = !1, this.url = e, this.protocolVersion = o.value.protocolVersion, this.supports.binary = "hixie-76" !== this.protocolVersion;
 var d = new Buffer(o.value.protocolVersion + "-" + Date.now()).toString("base64"),
  h = crypto.createHash("sha1");
 h.update(d + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
 var p = h.digest("base64"),
  f = o.value.agent,
  v = buildHostHeader(i, r.hostname, c),
  y = {
   port: c,
   host: r.hostname,
   headers: {
    Connection: "Upgrade",
    Upgrade: "websocket",
    Host: v,
    "Sec-WebSocket-Version": o.value.protocolVersion,
    "Sec-WebSocket-Key": d
   }
  };
 if (l && (y.headers.Authorization = "Basic " + new Buffer(l).toString("base64")), o.value.protocol && (y.headers["Sec-WebSocket-Protocol"] = o.value.protocol), o.value.host && (y.headers.Host = o.value.host), o.value.headers)
  for (var S in o.value.headers) o.value.headers.hasOwnProperty(S) && (y.headers[S] = o.value.headers[S]);
 Object.keys(u).length && (y.headers["Sec-WebSocket-Extensions"] = Extensions.format(u)), (o.isDefinedAndNonNull("pfx") || o.isDefinedAndNonNull("key") || o.isDefinedAndNonNull("passphrase") || o.isDefinedAndNonNull("cert") || o.isDefinedAndNonNull("ca") || o.isDefinedAndNonNull("ciphers") || o.isDefinedAndNonNull("rejectUnauthorized")) && (o.isDefinedAndNonNull("pfx") && (y.pfx = o.value.pfx), o.isDefinedAndNonNull("key") && (y.key = o.value.key), o.isDefinedAndNonNull("passphrase") && (y.passphrase = o.value.passphrase), o.isDefinedAndNonNull("cert") && (y.cert = o.value.cert), o.isDefinedAndNonNull("ca") && (y.ca = o.value.ca), o.isDefinedAndNonNull("ciphers") && (y.ciphers = o.value.ciphers), o.isDefinedAndNonNull("rejectUnauthorized") && (y.rejectUnauthorized = o.value.rejectUnauthorized), f || (f = new a.Agent(y))), y.path = r.path || "/", f && (y.agent = f), n && (y.socketPath = r.pathname), o.value.localAddress && (y.localAddress = o.value.localAddress), o.value.origin && (o.value.protocolVersion < 13 ? y.headers["Sec-WebSocket-Origin"] = o.value.origin : y.headers.Origin = o.value.origin);
 var b = this,
  m = a.request(y);
 m.on("error", function(e) {
  b.emit("error", e), cleanupWebsocketResources.call(b, e)
 }), m.once("response", function(e) {
  var t;
  b.emit("unexpected-response", m, e) || (t = new Error("unexpected server response (" + e.statusCode + ")"), m.abort(), b.emit("error", t)), cleanupWebsocketResources.call(b, t)
 }), m.once("upgrade", function(e, t, r) {
  if (b.readyState === WebSocket.CLOSED) return b.emit("close"), b.removeAllListeners(), void t.end();
  var n = e.headers["sec-websocket-accept"];
  if ("undefined" == typeof n || n !== p) return b.emit("error", "invalid server key"), b.removeAllListeners(), void t.end();
  var i = e.headers["sec-websocket-protocol"],
   a = (o.value.protocol || "").split(/, */),
   c = null;
  if (!o.value.protocol && i ? c = "server sent a subprotocol even though none requested" : o.value.protocol && !i ? c = "server sent no subprotocol even though requested" : i && -1 === a.indexOf(i) && (c = "server responded with an invalid protocol"), c) return b.emit("error", c), b.removeAllListeners(), void t.end();
  i && (b.protocol = i);
  var l = Extensions.parse(e.headers["sec-websocket-extensions"]);
  if (s && l[PerMessageDeflate.extensionName]) {
   try {
    s.accept(l[PerMessageDeflate.extensionName])
   } catch (u) {
    return b.emit("error", "invalid extension parameter"), b.removeAllListeners(), void t.end()
   }
   b.extensions[PerMessageDeflate.extensionName] = s
  }
  establishConnection.call(b, Receiver, Sender, t, r), m.removeAllListeners(), m = null, f = null
 }), m.end(), this.readyState = WebSocket.CONNECTING
}

function establishConnection(e, t, o, r) {
 function n(e) {
  a || c.readyState === WebSocket.CLOSED || (a = !0, o.removeListener("data", n), i.on("data", s), r && r.length > 0 && (s(r), r = null), e && s(e))
 }

 function s(e) {
  c.bytesReceived += e.length, c._receiver.add(e)
 }
 var i = this._ultron = new Ultron(o),
  a = !1,
  c = this;
 o.setTimeout(0), o.setNoDelay(!0), this._receiver = new e(this.extensions), this._socket = o, i.on("end", cleanupWebsocketResources.bind(this)), i.on("close", cleanupWebsocketResources.bind(this)), i.on("error", cleanupWebsocketResources.bind(this)), i.on("data", n), process.nextTick(n), c._receiver.ontext = function(e, t) {
  t = t || {}, c.emit("message", e, t)
 }, c._receiver.onbinary = function(e, t) {
  t = t || {}, t.binary = !0, c.emit("message", e, t)
 }, c._receiver.onping = function(e, t) {
  t = t || {}, c.pong(e, {
   mask: !c._isServer,
   binary: t.binary === !0
  }, !0), c.emit("ping", e, t)
 }, c._receiver.onpong = function(e, t) {
  c.emit("pong", e, t || {})
 }, c._receiver.onclose = function(e, t, o) {
  o = o || {}, c._closeReceived = !0, c.close(e, t)
 }, c._receiver.onerror = function(e, t) {
  c.close("undefined" != typeof t ? t : 1002, ""), c.emit("error", e, t)
 }, this._sender = new t(o, this.extensions), this._sender.on("error", function(e) {
  c.close(1002, ""), c.emit("error", e)
 }), this.readyState = WebSocket.OPEN, this.emit("open")
}

function startQueue(e) {
 e._queue = e._queue || []
}

function executeQueueSends(e) {
 var t = e._queue;
 if ("undefined" != typeof t) {
  delete e._queue;
  for (var o = 0, r = t.length; r > o; ++o) t[o]()
 }
}

function sendStream(e, t, o, r) {
 t.on("data", function(t) {
  return e.readyState !== WebSocket.OPEN ? void("function" == typeof r ? r(new Error("not opened")) : (delete e._queue, e.emit("error", new Error("not opened")))) : (o.fin = !1, void e._sender.send(t, o))
 }), t.on("end", function() {
  return e.readyState !== WebSocket.OPEN ? void("function" == typeof r ? r(new Error("not opened")) : (delete e._queue, e.emit("error", new Error("not opened")))) : (o.fin = !0, e._sender.send(null, o), void("function" == typeof r && r(null)))
 })
}

function cleanupWebsocketResources(e) {
 if (this.readyState !== WebSocket.CLOSED) {
  var t = this.readyState !== WebSocket.CONNECTING;
  if (this.readyState = WebSocket.CLOSED, clearTimeout(this._closeTimer), this._closeTimer = null, t && ((e || !this._closeReceived) && (this._closeCode = 1006), this.emit("close", this._closeCode || 1e3, this._closeMessage || "")), this._socket) {
   this._ultron && this._ultron.destroy(), this._socket.on("error", function() {
    try {
     this.destroy()
    } catch (e) {}
   });
   try {
    e ? this._socket.destroy() : this._socket.end()
   } catch (o) {}
   this._socket = null, this._ultron = null
  }
  this._sender && (this._sender.removeAllListeners(), this._sender = null), this._receiver && (this._receiver.cleanup(), this._receiver = null), this.extensions[PerMessageDeflate.extensionName] && this.extensions[PerMessageDeflate.extensionName].cleanup(), this.extensions = null, this.removeAllListeners(), this.on("error", function() {}), delete this._queue
 }
}
var url = require("url"),
 util = require("util"),
 http = require("http"),
 https = require("https"),
 crypto = require("crypto"),
 stream = require("stream"),
 Ultron = require("ultron"),
 Options = require("options"),
 Sender = require("./Sender"),
 Receiver = require("./Receiver"),
 SenderHixie = require("./Sender.hixie"),
 ReceiverHixie = require("./Receiver.hixie"),
 Extensions = require("./Extensions"),
 PerMessageDeflate = require("./PerMessageDeflate"),
 EventEmitter = require("events").EventEmitter,
 protocolVersion = 13,
 closeTimeout = 3e4;
util.inherits(WebSocket, EventEmitter), ["CONNECTING", "OPEN", "CLOSING", "CLOSED"].forEach(function(e, t) {
 WebSocket.prototype[e] = WebSocket[e] = t
}), WebSocket.prototype.close = function(e, t) {
 if (this.readyState !== WebSocket.CLOSED) {
  if (this.readyState === WebSocket.CONNECTING) return void(this.readyState = WebSocket.CLOSED);
  if (this.readyState === WebSocket.CLOSING) return void(this._closeReceived && this._isServer && this.terminate());
  var o = this;
  try {
   this.readyState = WebSocket.CLOSING, this._closeCode = e, this._closeMessage = t;
   var r = !this._isServer;
   this._sender.close(e, t, r, function(e) {
    e && o.emit("error", e), o._closeReceived && o._isServer ? o.terminate() : (clearTimeout(o._closeTimer), o._closeTimer = setTimeout(cleanupWebsocketResources.bind(o, !0), closeTimeout))
   })
  } catch (n) {
   this.emit("error", n)
  }
 }
}, WebSocket.prototype.pause = function() {
 if (this.readyState !== WebSocket.OPEN) throw new Error("not opened");
 return this._socket.pause()
}, WebSocket.prototype.ping = function(e, t, o) {
 if (this.readyState !== WebSocket.OPEN) {
  if (o === !0) return;
  throw new Error("not opened")
 }
 t = t || {}, "undefined" == typeof t.mask && (t.mask = !this._isServer), this._sender.ping(e, t)
}, WebSocket.prototype.pong = function(e, t, o) {
 if (this.readyState !== WebSocket.OPEN) {
  if (o === !0) return;
  throw new Error("not opened")
 }
 t = t || {}, "undefined" == typeof t.mask && (t.mask = !this._isServer), this._sender.pong(e, t)
}, WebSocket.prototype.resume = function() {
 if (this.readyState !== WebSocket.OPEN) throw new Error("not opened");
 return this._socket.resume()
}, WebSocket.prototype.send = function(e, t, o) {
 if ("function" == typeof t && (o = t, t = {}), this.readyState !== WebSocket.OPEN) {
  if ("function" != typeof o) throw new Error("not opened");
  return void o(new Error("not opened"))
 }
 if (e || (e = ""), this._queue) {
  var r = this;
  return void this._queue.push(function() {
   r.send(e, t, o)
  })
 }
 t = t || {}, t.fin = !0, "undefined" == typeof t.binary && (t.binary = e instanceof ArrayBuffer || e instanceof Buffer || e instanceof Uint8Array || e instanceof Uint16Array || e instanceof Uint32Array || e instanceof Int8Array || e instanceof Int16Array || e instanceof Int32Array || e instanceof Float32Array || e instanceof Float64Array), "undefined" == typeof t.mask && (t.mask = !this._isServer), "undefined" == typeof t.compress && (t.compress = !0), this.extensions[PerMessageDeflate.extensionName] || (t.compress = !1);
 var n = "function" == typeof stream.Readable ? stream.Readable : stream.Stream;
 if (e instanceof n) {
  startQueue(this);
  var r = this;
  sendStream(this, e, t, function(e) {
   process.nextTick(function() {
    executeQueueSends(r)
   }), "function" == typeof o && o(e)
  })
 } else this._sender.send(e, t, o)
}, WebSocket.prototype.stream = function(e, t) {
 function o(n, s) {
  try {
   if (r.readyState !== WebSocket.OPEN) throw new Error("not opened");
   e.fin = s === !0, r._sender.send(n, e), s ? executeQueueSends(r) : process.nextTick(t.bind(null, null, o))
  } catch (i) {
   "function" == typeof t ? t(i) : (delete r._queue, r.emit("error", i))
  }
 }
 "function" == typeof e && (t = e, e = {});
 var r = this;
 if ("function" != typeof t) throw new Error("callback must be provided");
 if (this.readyState !== WebSocket.OPEN) {
  if ("function" != typeof t) throw new Error("not opened");
  return void t(new Error("not opened"))
 }
 return this._queue ? void this._queue.push(function() {
  r.stream(e, t)
 }) : (e = e || {}, "undefined" == typeof e.mask && (e.mask = !this._isServer), "undefined" == typeof e.compress && (e.compress = !0), this.extensions[PerMessageDeflate.extensionName] || (e.compress = !1), startQueue(this), void process.nextTick(t.bind(null, null, o)))
}, WebSocket.prototype.terminate = function() {
 if (this.readyState !== WebSocket.CLOSED)
  if (this._socket) {
   this.readyState = WebSocket.CLOSING;
   try {
    this._socket.end()
   } catch (e) {
    return void cleanupWebsocketResources.call(this, !0)
   }
   this._closeTimer && clearTimeout(this._closeTimer), this._closeTimer = setTimeout(cleanupWebsocketResources.bind(this, !0), closeTimeout)
  } else this.readyState === WebSocket.CONNECTING && cleanupWebsocketResources.call(this, !0)
}, Object.defineProperty(WebSocket.prototype, "bufferedAmount", {
 get: function() {
  var e = 0;
  return this._socket && (e = this._socket.bufferSize || 0), e
 }
}), ["open", "error", "close", "message"].forEach(function(e) {
 Object.defineProperty(WebSocket.prototype, "on" + e, {
  get: function() {
   var t = this.listeners(e)[0];
   return t ? t._listener ? t._listener : t : void 0
  },
  set: function(t) {
   this.removeAllListeners(e), this.addEventListener(e, t)
  }
 })
}), WebSocket.prototype.addEventListener = function(e, t) {
 function o(e, o) {
  t.call(i, new MessageEvent(e, !!o.binary, i))
 }

 function r(e, o) {
  t.call(i, new CloseEvent(e, o, i))
 }

 function n(e) {
  e.type = "error", e.target = i, t.call(i, e)
 }

 function s() {
  t.call(i, new OpenEvent(i))
 }
 var i = this;
 "function" == typeof t && ("message" === e ? (o._listener = t, this.on(e, o)) : "close" === e ? (r._listener = t, this.on(e, r)) : "error" === e ? (n._listener = t, this.on(e, n)) : "open" === e ? (s._listener = t, this.on(e, s)) : this.on(e, t))
}, module.exports = WebSocket, module.exports.buildHostHeader = buildHostHeader;
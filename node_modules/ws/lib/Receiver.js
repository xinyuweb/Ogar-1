function Receiver(e) {
 if (this instanceof Receiver == !1) throw new TypeError("Classes can't be function-called");
 var t = -1;
 this.fragmentedBufferPool = new BufferPool(1024, function(e, t) {
  return e.used + t
 }, function(e) {
  return t = t >= 0 ? Math.ceil((t + e.used) / 2) : e.used
 });
 var s = -1;
 this.unfragmentedBufferPool = new BufferPool(1024, function(e, t) {
  return e.used + t
 }, function(e) {
  return s = s >= 0 ? Math.ceil((s + e.used) / 2) : e.used
 }), this.extensions = e || {}, this.state = {
  activeFragmentedOperation: null,
  lastFragment: !1,
  masked: !1,
  opcode: 0,
  fragmentedOperation: !1
 }, this.overflow = [], this.headerBuffer = new Buffer(10), this.expectOffset = 0, this.expectBuffer = null, this.expectHandler = null, this.currentMessage = [], this.messageHandlers = [], this.expectHeader(2, this.processPacket), this.dead = !1, this.processing = !1, this.onerror = function() {}, this.ontext = function() {}, this.onbinary = function() {}, this.onclose = function() {}, this.onping = function() {}, this.onpong = function() {}
}

function readUInt16BE(e) {
 return (this[e] << 8) + this[e + 1]
}

function readUInt32BE(e) {
 return (this[e] << 24) + (this[e + 1] << 16) + (this[e + 2] << 8) + this[e + 3]
}

function fastCopy(e, t, s, r) {
 switch (e) {
  default: t.copy(s, r, 0, e);
  break;
  case 16:
    s[r + 15] = t[15];
  case 15:
    s[r + 14] = t[14];
  case 14:
    s[r + 13] = t[13];
  case 13:
    s[r + 12] = t[12];
  case 12:
    s[r + 11] = t[11];
  case 11:
    s[r + 10] = t[10];
  case 10:
    s[r + 9] = t[9];
  case 9:
    s[r + 8] = t[8];
  case 8:
    s[r + 7] = t[7];
  case 7:
    s[r + 6] = t[6];
  case 6:
    s[r + 5] = t[5];
  case 5:
    s[r + 4] = t[4];
  case 4:
    s[r + 3] = t[3];
  case 3:
    s[r + 2] = t[2];
  case 2:
    s[r + 1] = t[1];
  case 1:
    s[r] = t[0]
 }
}

function clone(e) {
 var t = {};
 for (var s in e) e.hasOwnProperty(s) && (t[s] = e[s]);
 return t
}
var util = require("util"),
 Validation = require("./Validation").Validation,
 ErrorCodes = require("./ErrorCodes"),
 BufferPool = require("./BufferPool"),
 bufferUtil = require("./BufferUtil").BufferUtil,
 PerMessageDeflate = require("./PerMessageDeflate");
module.exports = Receiver, Receiver.prototype.add = function(e) {
 var t = e.length;
 if (0 != t) {
  if (null == this.expectBuffer) return void this.overflow.push(e);
  var s = Math.min(t, this.expectBuffer.length - this.expectOffset);
  for (fastCopy(s, e, this.expectBuffer, this.expectOffset), this.expectOffset += s, t > s && this.overflow.push(e.slice(s)); this.expectBuffer && this.expectOffset == this.expectBuffer.length;) {
   var r = this.expectBuffer;
   this.expectBuffer = null, this.expectOffset = 0, this.expectHandler.call(this, r)
  }
 }
}, Receiver.prototype.cleanup = function() {
 this.dead = !0, this.overflow = null, this.headerBuffer = null, this.expectBuffer = null, this.expectHandler = null, this.unfragmentedBufferPool = null, this.fragmentedBufferPool = null, this.state = null, this.currentMessage = null, this.onerror = null, this.ontext = null, this.onbinary = null, this.onclose = null, this.onping = null, this.onpong = null
}, Receiver.prototype.expectHeader = function(e, t) {
 if (0 == e) return void t(null);
 this.expectBuffer = this.headerBuffer.slice(this.expectOffset, this.expectOffset + e), this.expectHandler = t;
 for (var s = e; s > 0 && this.overflow.length > 0;) {
  var r = this.overflow.pop();
  s < r.length && this.overflow.push(r.slice(s));
  var n = Math.min(r.length, s);
  fastCopy(n, r, this.expectBuffer, this.expectOffset), this.expectOffset += n, s -= n
 }
}, Receiver.prototype.expectData = function(e, t) {
 if (0 == e) return void t(null);
 this.expectBuffer = this.allocateFromPool(e, this.state.fragmentedOperation), this.expectHandler = t;
 for (var s = e; s > 0 && this.overflow.length > 0;) {
  var r = this.overflow.pop();
  s < r.length && this.overflow.push(r.slice(s));
  var n = Math.min(r.length, s);
  fastCopy(n, r, this.expectBuffer, this.expectOffset), this.expectOffset += n, s -= n
 }
}, Receiver.prototype.allocateFromPool = function(e, t) {
 return (t ? this.fragmentedBufferPool : this.unfragmentedBufferPool).get(e)
}, Receiver.prototype.processPacket = function(e) {
 if (this.extensions[PerMessageDeflate.extensionName]) {
  if (0 != (48 & e[0])) return void this.error("reserved fields (2, 3) must be empty", 1002)
 } else if (0 != (112 & e[0])) return void this.error("reserved fields must be empty", 1002);
 this.state.lastFragment = 128 == (128 & e[0]), this.state.masked = 128 == (128 & e[1]);
 var t = 64 == (64 & e[0]),
  s = 15 & e[0];
 if (0 === s) {
  if (t) return void this.error("continuation frame cannot have the Per-message Compressed bits", 1002);
  if (this.state.fragmentedOperation = !0, this.state.opcode = this.state.activeFragmentedOperation, 1 != this.state.opcode && 2 != this.state.opcode) return void this.error("continuation frame cannot follow current opcode", 1002)
 } else {
  if (3 > s && null != this.state.activeFragmentedOperation) return void this.error("data frames after the initial data frame must have opcode 0", 1002);
  if (s >= 8 && t) return void this.error("control frames cannot have the Per-message Compressed bits", 1002);
  this.state.compressed = t, this.state.opcode = s, this.state.lastFragment === !1 ? (this.state.fragmentedOperation = !0, this.state.activeFragmentedOperation = s) : this.state.fragmentedOperation = !1
 }
 var r = opcodes[this.state.opcode];
 "undefined" == typeof r ? this.error("no handler for opcode " + this.state.opcode, 1002) : r.start.call(this, e)
}, Receiver.prototype.endPacket = function() {
 this.state.fragmentedOperation ? this.state.lastFragment && this.fragmentedBufferPool.reset(!0) : this.unfragmentedBufferPool.reset(!0), this.expectOffset = 0, this.expectBuffer = null, this.expectHandler = null, this.state.lastFragment && this.state.opcode === this.state.activeFragmentedOperation && (this.state.activeFragmentedOperation = null), this.state.lastFragment = !1, this.state.opcode = null != this.state.activeFragmentedOperation ? this.state.activeFragmentedOperation : 0, this.state.masked = !1, this.expectHeader(2, this.processPacket)
}, Receiver.prototype.reset = function() {
 this.dead || (this.state = {
  activeFragmentedOperation: null,
  lastFragment: !1,
  masked: !1,
  opcode: 0,
  fragmentedOperation: !1
 }, this.fragmentedBufferPool.reset(!0), this.unfragmentedBufferPool.reset(!0), this.expectOffset = 0, this.expectBuffer = null, this.expectHandler = null, this.overflow = [], this.currentMessage = [], this.messageHandlers = [])
}, Receiver.prototype.unmask = function(e, t, s) {
 return null != e && null != t && bufferUtil.unmask(t, e), s ? t : null != t ? t.toString("utf8") : ""
}, Receiver.prototype.concatBuffers = function(e) {
 for (var t = 0, s = 0, r = e.length; r > s; ++s) t += e[s].length;
 var n = new Buffer(t);
 return bufferUtil.merge(n, e), n
}, Receiver.prototype.error = function(e, t) {
 return this.reset(), this.onerror(e, t), this
}, Receiver.prototype.flush = function() {
 if (!this.processing && !this.dead) {
  var e = this.messageHandlers.shift();
  if (e) {
   this.processing = !0;
   var t = this;
   e(function() {
    t.processing = !1, t.flush()
   })
  }
 }
}, Receiver.prototype.applyExtensions = function(e, t, s, r) {
 var n = this;
 s ? this.extensions[PerMessageDeflate.extensionName].decompress(e, t, function(e, t) {
  return n.dead ? void 0 : e ? void r(new Error("invalid compressed data")) : void r(null, t)
 }) : r(null, e)
};
var opcodes = {
 1: {
  start: function(e) {
   var t = this,
    s = 127 & e[1];
   126 > s ? opcodes[1].getData.call(t, s) : 126 == s ? t.expectHeader(2, function(e) {
    opcodes[1].getData.call(t, readUInt16BE.call(e, 0))
   }) : 127 == s && t.expectHeader(8, function(e) {
    return 0 != readUInt32BE.call(e, 0) ? void t.error("packets with length spanning more than 32 bit is currently not supported", 1008) : void opcodes[1].getData.call(t, readUInt32BE.call(e, 4))
   })
  },
  getData: function(e) {
   var t = this;
   t.state.masked ? t.expectHeader(4, function(s) {
    var r = s;
    t.expectData(e, function(e) {
     opcodes[1].finish.call(t, r, e)
    })
   }) : t.expectData(e, function(e) {
    opcodes[1].finish.call(t, null, e)
   })
  },
  finish: function(e, t) {
   var s = this,
    r = this.unmask(e, t, !0) || new Buffer(0),
    n = clone(this.state);
   this.messageHandlers.push(function(e) {
    s.applyExtensions(r, n.lastFragment, n.compressed, function(t, r) {
     if (t) return s.error(t.message, 1007);
     if (null != r && s.currentMessage.push(r), n.lastFragment) {
      var a = s.concatBuffers(s.currentMessage);
      if (s.currentMessage = [], !Validation.isValidUTF8(a)) return void s.error("invalid utf8 sequence", 1007);
      s.ontext(a.toString("utf8"), {
       masked: n.masked,
       buffer: a
      })
     }
     e()
    })
   }), this.flush(), this.endPacket()
  }
 },
 2: {
  start: function(e) {
   var t = this,
    s = 127 & e[1];
   126 > s ? opcodes[2].getData.call(t, s) : 126 == s ? t.expectHeader(2, function(e) {
    opcodes[2].getData.call(t, readUInt16BE.call(e, 0))
   }) : 127 == s && t.expectHeader(8, function(e) {
    return 0 != readUInt32BE.call(e, 0) ? void t.error("packets with length spanning more than 32 bit is currently not supported", 1008) : void opcodes[2].getData.call(t, readUInt32BE.call(e, 4, !0))
   })
  },
  getData: function(e) {
   var t = this;
   t.state.masked ? t.expectHeader(4, function(s) {
    var r = s;
    t.expectData(e, function(e) {
     opcodes[2].finish.call(t, r, e)
    })
   }) : t.expectData(e, function(e) {
    opcodes[2].finish.call(t, null, e)
   })
  },
  finish: function(e, t) {
   var s = this,
    r = this.unmask(e, t, !0) || new Buffer(0),
    n = clone(this.state);
   this.messageHandlers.push(function(e) {
    s.applyExtensions(r, n.lastFragment, n.compressed, function(t, r) {
     if (t) return s.error(t.message, 1007);
     if (null != r && s.currentMessage.push(r), n.lastFragment) {
      var a = s.concatBuffers(s.currentMessage);
      s.currentMessage = [], s.onbinary(a, {
       masked: n.masked,
       buffer: a
      })
     }
     e()
    })
   }), this.flush(), this.endPacket()
  }
 },
 8: {
  start: function(e) {
   var t = this;
   if (0 == t.state.lastFragment) return void t.error("fragmented close is not supported", 1002);
   var s = 127 & e[1];
   126 > s ? opcodes[8].getData.call(t, s) : t.error("control frames cannot have more than 125 bytes of data", 1002)
  },
  getData: function(e) {
   var t = this;
   t.state.masked ? t.expectHeader(4, function(s) {
    var r = s;
    t.expectData(e, function(e) {
     opcodes[8].finish.call(t, r, e)
    })
   }) : t.expectData(e, function(e) {
    opcodes[8].finish.call(t, null, e)
   })
  },
  finish: function(e, t) {
   var s = this;
   t = s.unmask(e, t, !0);
   var r = clone(this.state);
   this.messageHandlers.push(function() {
    if (t && 1 == t.length) return void s.error("close packets with data must be at least two bytes long", 1002);
    var e = t && t.length > 1 ? readUInt16BE.call(t, 0) : 1e3;
    if (!ErrorCodes.isValidErrorCode(e)) return void s.error("invalid error code", 1002);
    var n = "";
    if (t && t.length > 2) {
     var a = t.slice(2);
     if (!Validation.isValidUTF8(a)) return void s.error("invalid utf8 sequence", 1007);
     n = a.toString("utf8")
    }
    s.onclose(e, n, {
     masked: r.masked
    }), s.reset()
   }), this.flush()
  }
 },
 9: {
  start: function(e) {
   var t = this;
   if (0 == t.state.lastFragment) return void t.error("fragmented ping is not supported", 1002);
   var s = 127 & e[1];
   126 > s ? opcodes[9].getData.call(t, s) : t.error("control frames cannot have more than 125 bytes of data", 1002)
  },
  getData: function(e) {
   var t = this;
   t.state.masked ? t.expectHeader(4, function(s) {
    var r = s;
    t.expectData(e, function(e) {
     opcodes[9].finish.call(t, r, e)
    })
   }) : t.expectData(e, function(e) {
    opcodes[9].finish.call(t, null, e)
   })
  },
  finish: function(e, t) {
   var s = this;
   t = this.unmask(e, t, !0);
   var r = clone(this.state);
   this.messageHandlers.push(function(e) {
    s.onping(t, {
     masked: r.masked,
     binary: !0
    }), e()
   }), this.flush(), this.endPacket()
  }
 },
 10: {
  start: function(e) {
   var t = this;
   if (0 == t.state.lastFragment) return void t.error("fragmented pong is not supported", 1002);
   var s = 127 & e[1];
   126 > s ? opcodes[10].getData.call(t, s) : t.error("control frames cannot have more than 125 bytes of data", 1002)
  },
  getData: function(e) {
   var t = this;
   this.state.masked ? this.expectHeader(4, function(s) {
    var r = s;
    t.expectData(e, function(e) {
     opcodes[10].finish.call(t, r, e)
    })
   }) : this.expectData(e, function(e) {
    opcodes[10].finish.call(t, null, e)
   })
  },
  finish: function(e, t) {
   var s = this;
   t = s.unmask(e, t, !0);
   var r = clone(this.state);
   this.messageHandlers.push(function(e) {
    s.onpong(t, {
     masked: r.masked,
     binary: !0
    }), e()
   }), this.flush(), this.endPacket()
  }
 }
};
function Options(e) {
 var n = {},
  t = this.value = {};
 Object.keys(e).forEach(function(r) {
  n[r] = e[r], Object.defineProperty(t, r, {
   get: function() {
    return n[r]
   },
   configurable: !1,
   enumerable: !0
  })
 }), this.reset = function() {
  return Object.keys(e).forEach(function(t) {
   n[t] = e[t]
  }), this
 }, this.merge = function(e, t) {
  if (e = e || {}, "[object Array]" === Object.prototype.toString.call(t)) {
   for (var r = [], i = 0, o = t.length; o > i; ++i) {
    var f = t[i];
    f in e || r.push(f)
   }
   if (r.length > 0) throw r.length > 1 ? new Error("options " + r.slice(0, r.length - 1).join(", ") + " and " + r[r.length - 1] + " must be defined") : new Error("option " + r[0] + " must be defined")
  }
  return Object.keys(e).forEach(function(t) {
   t in n && (n[t] = e[t])
  }), this
 }, this.copy = function(n) {
  var r = {};
  return Object.keys(e).forEach(function(e) {
   -1 !== n.indexOf(e) && (r[e] = t[e])
  }), r
 }, this.read = function(e, n) {
  if ("function" == typeof n) {
   var t = this;
   fs.readFile(e, function(e, r) {
    if (e) return n(e);
    var i = JSON.parse(r);
    t.merge(i), n()
   })
  } else {
   var r = JSON.parse(fs.readFileSync(e));
   this.merge(r)
  }
  return this
 }, this.isDefined = function(e) {
  return "undefined" != typeof t[e]
 }, this.isDefinedAndNonNull = function(e) {
  return "undefined" != typeof t[e] && null !== t[e]
 }, Object.freeze(t), Object.freeze(this)
}
var fs = require("fs");
module.exports = Options;